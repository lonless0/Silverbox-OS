types: byte int16 int32 int64
complex: string/binary (sequence of bytes), array( sequence of types ), hash

data is in little endian format

\x*0 - null/zero

\x*3 <8-bit value> - int8/uint8
\x*4 <16-bit value> - int16/uint16
\x*5 <32-bit value> - int32/uint32
\x*6 <64-bit value> - int64/uint32

\x01 - true(boolean)
\x02 - false(boolean)
\x07 <128-bit value> - UUID
\x08 <64-bit IEEE floating point> - double

complex (least significant nibble is ORed with a storage type variable

lengths and sizes are always unsigned

* = storage class for the length/count of the collection/sequence

\x2* (number of elements) ...(array data) - array
\x3* (size of string/binary[in bytes]) ...(bytes) - string/binary sequence
\x4* (number of pairs) <key value>* - associative array

[null, 2,'hello',{'yes': [1,true]}]  would be encoded as:

   [  null          2                   'hello' {            'yes' [            1              true ]}]
"\x23\x04\x00\x05\x02\x00\x00\x00\x33\x05hello\x43\x01\x33\x03yes\x23\x02\x05\x01\x00\x00\x00\x01"

rpc call and response

rpc call

[\x01] (protocol number) \x50 [\x3* ...](string: function_name)
	[\x07 ...] (uuid: tag) [\x2* or \x4* or \x00](arguments[if any])

rpc response

\x01 (protocol number) \x60 [\x3* ...](string: function_name)
	[\x07 ...] (uuid: tag) [\x2* or \x4* or \x00](arguments[if any])
